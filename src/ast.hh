
/*********************************************************************************************

                                cfglp : A CFG Language Processor
                                --------------------------------

               About:
               Implemented by Uday Khedker (http://www.cse.iitb.ac.in/~uday) for 
               the courses cs302+cs306: Language Processors (theory and lab) at
               IIT Bombay. Release date Jan 6, 2013. Copyrights reserved by Uday
               Khedker. This implemenation has been made available purely for
               academic purposes without any warranty of any kind.

               Please see the README file for some details. A doxygen generated
               documentation can be found at http://www.cse.iitb.ac.in/~uday/cfglp


***********************************************************************************************/

#include <iostream>
#include <cstdlib>
#include <string>
#include <vector>
#include <list>

using namespace std;


/*   
   Our AST consists of ast_Node objects. Each node has an operator with 
   a known arity. This is an abstract base class from which different
   kinds of AST nodes are derived. In this version we have four kinds
   of AST Nodes:

   - Assignment nodes (asgn_Ast) which are binary nodes.
   - Name nodes (name_Ast) which are leaf nodes and can appear in
     the RHS or LHS of assignment nodes.
   - Number nodes (num_Ast) which are leaf nodes and can appear only
     in the RHS of an assignment node.
   - Return node (ret_Ast) which is a leaf node corresponding to a special
     return statement generated by GCC in a cfg dump regardless of whether
     it is present in the input C program or not.

   These nodes have additional fields as appropriate.

   This file describes the interface. The implementation is contained in the
   file ast.cc.

    Tha modified hierarchy is as follows:

    if_ast<---------- ast_ptr -----------> goto_ast
                     /   |    \
                 /     /   \      \
            /        /       \          \
        asgn_Ast ret_Ast  ret_void_ast  expr_Ast --------> func_ast
                                        /  |  \
                                    /      |     \ 
                                /          |         \             |-> float_Ast
                            name_Ast    op_Ast      num_Ast -------|
                                         /  \                      |-> int_Ast
                                      /        \
                            unary_op_Ast     binary_op_Ast--------------------------------------+
                                |                   |                                           |
                        unary_minus_Ast             |                                           |
                                        -------------------------             +---------------------------------------+
                                        |       |       |       |             |        |       |        |      |      |
                                    mult_Ast div_Ast plus_Ast minus_Ast    geq_Ast  leq_Ast  gt_Ast  lt_ast neq_Ast eq_ast
*/

typedef enum {asgn, ret, name_Leaf, float_Leaf, int_Leaf, plus_node, minus_node, unary_minus_node, div_node, mult_node, geq_node, leq_node, gt_node, lt_node, eq_node, neq_node, goto_node, if_node} ast_Op;
typedef enum {zero_Arity=0, unary=1, binary=2} ast_Arity;   

class ast_Node;
typedef ast_Node* ast_Ptr;
typedef list <ast_Ptr> * ast_List_Ptr;


class ast_Node
{   
  public:
    ast_Op t_op;
    ast_Arity node_arity;
    double fum;
    int num;
    ast_Ptr left;
    ast_Ptr right;
    ast_Ptr ft;
    int lineno;
    bool delete_flag;
    ast_Node() {}
    virtual ~ast_Node() {}

    ast_Op get_Tree_Op() { return t_op; }

    virtual void print_Node(ostream *p) = 0;

    /* Type checking functions */
    virtual void type_Check() ; 
    virtual value_Type get_Val_Type(); 
    virtual entity_Type get_Entity_Type(); 
    virtual string get_Name();
    virtual int get_Int();
    virtual double get_Float();

    /* Evaluation functions */
    virtual eval_Result evaluate() = 0;
    virtual eval_Result get_Value_of_Evaluation();
    virtual void set_Value_of_Evaluation(eval_Result res);
    virtual sym_Entry_Ptr get_Sym_Entry();

    /* Compilation functions */
    virtual ast_Code_Ptr compile();
};

class asgn_Ast: public ast_Node
{
  public:
    asgn_Ast(ast_Ptr l, ast_Ptr  r, int line);
    ~asgn_Ast() {}
    asgn_Ast& operator=(const asgn_Ast& rhs);


    /* Type checking functions */
    void type_Check();
    entity_Type get_Entity_Type();
    int get_Line_Number();

    /* Evaluation functions */
    eval_Result evaluate();
    void print_Eval_Result(asgn_Ast * ast);

    /* Compilation functions */
    ast_Code_Ptr compile();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class ret_Ast: public ast_Node
{
  public:
    ret_Ast(int line);
    ~ret_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class goto_Ast: public ast_Node
{
  public:
    goto_Ast(int id, int line);
    ~goto_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();
    void print_Eval_Result(goto_Ast * ast);
    int get_Int();

    /* Other printing functions */
    void print_Node(ostream *p);

    /* Compilation functions */
    ast_Code_Ptr compile();
};

class if_Ast: public ast_Node
{
  public:
    if_Ast(ast_Ptr cond, ast_Ptr l, ast_Ptr r, int line);
    ~if_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();
    void print_Eval_Result(if_Ast * ast);

    /* Other printing functions */
    void print_Node(ostream *p);

    /* Compilation functions */
    ast_Code_Ptr compile();
};

class expr_Ast: public ast_Node
{
  public:
	expr_Ast() {}
	~expr_Ast() {}
};

class name_Ast: public expr_Ast
{
    string name;
    sym_Entry_Ptr sym_entry;

  public:
    name_Ast(string n, int line);
    ~name_Ast() {}

    /* Common function required for many activities */
    sym_Entry_Ptr get_Sym_Entry();
    string get_Name();

    /* Type checking functions */
    value_Type get_Val_Type();
    entity_Type get_Entity_Type();

    /* Evaluation functions */
    eval_Result evaluate();
    eval_Result get_Value_of_Evaluation();
    void set_Value_of_Evaluation(eval_Result res);

    /* Compilation functions */
    ast_Code_Ptr compile();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class num_Ast: public expr_Ast
{
  public:
    num_Ast() {}
    ~num_Ast() {}
};

class int_Ast: public num_Ast
{
  public:
    int_Ast(int n, int line);
    ~int_Ast() {}

    /* Other printing functions */
    void print_Node(ostream *p);

    /* Common function required for many activities */
    int get_Int();

    /* Evaluation functions */
    value_Type get_Val_Type();
    eval_Result evaluate();
    string get_Name();

    /* Compilation functions */
    ast_Code_Ptr compile();
};

class float_Ast: public num_Ast
{
  public:
    float_Ast(double f, int line);
    ~float_Ast() {}
    
    /* Other printing functions */
    void print_Node(ostream *p);

    /* Common function required for many activities */
    double get_Float();

    /* Evaluation functions */
    value_Type get_Val_Type();
    eval_Result evaluate();
    string get_Name();

    /* Compilation functions */
    ast_Code_Ptr compile();
};

class op_Ast: public expr_Ast
{
  public:
    op_Ast() {}
    ~op_Ast() {}
};

class binary_op_Ast: public op_Ast
{
  public:
    binary_op_Ast(ast_Ptr l, ast_Ptr r, int line);
    ~binary_op_Ast() {}

    /* Type checking functions */
    void type_Check();
    value_Type get_Val_Type(); 

    /* Compilation functions */
    ast_Code_Ptr compile();
};

class  mult_Ast: public binary_op_Ast
{
  public:
     mult_Ast(ast_Ptr l, ast_Ptr r, int line);
    ~mult_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class  div_Ast : public binary_op_Ast
{
  public:
     div_Ast(ast_Ptr l, ast_Ptr r, int line);
    ~div_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class  plus_Ast : public binary_op_Ast
{
  public:
     plus_Ast(ast_Ptr l, ast_Ptr r, int line);
    ~plus_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class minus_Ast : public binary_op_Ast
{
  public:
     minus_Ast(ast_Ptr l, ast_Ptr r, int line);
    ~minus_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class rel_op_Ast : public binary_op_Ast
{
  public:
    rel_op_Ast(ast_Ptr l, ast_Ptr r, int line);
    ~rel_op_Ast() {}
};

class geq_Ast: public rel_op_Ast
{
  public:
     geq_Ast(ast_Ptr l, ast_Ptr r, int line);
    ~geq_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class leq_Ast: public rel_op_Ast
{
  public:
     leq_Ast(ast_Ptr l, ast_Ptr r, int line);
    ~leq_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class gt_Ast: public rel_op_Ast
{
  public:
     gt_Ast(ast_Ptr l, ast_Ptr r, int line);
    ~gt_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class lt_Ast: public rel_op_Ast
{
  public:
     lt_Ast(ast_Ptr l, ast_Ptr r, int line);
    ~lt_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class neq_Ast: public rel_op_Ast
{
  public:
     neq_Ast(ast_Ptr l, ast_Ptr r, int line);
    ~neq_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class eq_Ast: public rel_op_Ast
{
  public:
     eq_Ast(ast_Ptr l, ast_Ptr r, int line);
    ~eq_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Other printing functions */
    void print_Node(ostream *p);
};

class unary_op_Ast: public op_Ast
{
  public:
    unary_op_Ast(ast_Ptr p, int line);
    ~unary_op_Ast() {}

     /* Type checking functions */
    void type_Check(); 
    value_Type get_Val_Type(); 

    /* Compilation functions */
    ast_Code_Ptr compile();
};

class unary_minus_Ast: public unary_op_Ast
{
  public:
    unary_minus_Ast(ast_Ptr p, int line);
    ~unary_minus_Ast() {}

    /* Evaluation functions */
    eval_Result evaluate();

    /* Other printing functions */
    void print_Node(ostream *p);
};
